# **PID Control**

### Writeup

The purpose of this project is to enable vehicles to drive around the lake race track using PID controller. I followd lesson 12 and implemented the code in C++. Using the hyperparameters given in the Section11 quiz(Kp = 0.2, Kd = 3.0, Ki = 0.004), the vehicle was able to drive at the lowest speed without getting off the road. So I tried to adjust the hyperparameters to make the car drive faster.
---

[//]: # (Image References)

[image1]: ./writeup/1_outoflane.jpg "start_graph"

### Rubric Points
Here I will consider the [rubric points](https://review.udacity.com/#!/rubrics/1972/view). Following criterias were addressed in detail.

---
### 1. Describe the effect each of the P, I, D components had in my implementation.
#### 1.1 Effects of P component
The P component is the component proportional to the cross track error. It has the effect of turning the steering wheel toward the center of the lane if the cte is large. Therefore, if the coefficient of P (Kp) is too small, the force to pull the vehicle back to the center of the lane will be weak. On the other hand, if the Kp is large, the vehicle will oscillate significantly as it is suddenly pulled back to the center.
I put the following two videos in the writeup folder.
./writeup/1.1_p_00.mp4 :: Kp = 0
./writeup/1.1_p_09.mp4 :: Kp = 0.8

#### 1.2 Effects of D component
The D component has the function to prevent overshoot by reducing the force to pull back to the center when the cte becomes small. However, in the lake race trace, the cte may become large because the road is curved. Therefore, if the d component is small, it will not be able to respond quickly to the curve and will be off the road. On the other hand, if the d component is large, it will overreact to the cte generated by the curve, and the direction of the car will change abruptly. As a result, the car will not go out of the lane, but it will be less comfortable to ride.
Below are two videos showing these situations.
./writeup/1.2_d_00.mp4 Kd = 0
./writeup/1.2_d_90.mp4 Kd = 9.0

#### 1.3 Effects of I component
The i component is a component for canceling the systematic bias, and is effective when the angle of the handle is not adjusted to exactly 0. However, when driving on the lake race track, setting Ki = 0 did not cause any noticeable problems. I think this was because there was no systematic bias and there are few straight roads, so the impact was difficult to understand. On the other hand, increasing Ki caused extra oscillation at the starting point. This was probably due to an overreaction of the car off the center of the lane at the starting point.
I put a following video in the writeup folder.
./writeup/1.3_i_0.02.mp4 Ki = 0.02


### 2. Describe how the final hyperparameters were chosen.
Next, I adjusted the hyperparameters. As I was very impressed with the method called twiddle explained in section13, I wanted to implement it. However, while the quiz implementation was not  difficult, I could not easily come up with a suitable implementation for this project.
Since the environment did not change in the quiz, I was able to adjust the hyperparameters by averaging every 100 steps. Meanwhile, the cte was increased by curved roads on the lake race track.
Averaging cte across the whole track would make tuning accurate, but it would take too long to adjust.

#### 2.1 Manual Tuning
Before talking about how I implemented twiddle, I would like to explane manual tuning.
At first, I used original parameters given at quiz in Section11. I saved the video at that time in writeup/suc01.mp4. The vehicle was able to drive without leaving the lane. But that was partly because it was slow.

Then I tried to increase the throttle to change the speed when steer_value was small.

```
if((steer_value > 0.5 || steer_value < -0.5) && base_throttle >= 0.3){
  base_throttle -= 0.01;
}
else if(steer_value < 0.3 && steer_value > -0.3 && base_throttle <= 0.5){
  base_throttle += 0.01;
}
```
As a result, the vehicle was able to drive faster, but sometimes it was out of the lane.

![alt text][image1]

Therefore, I manually adjusted the parameters so that the car could drive safely. Here is the result of my manual tuning. And the resulting movie was saved as ./writeup/suc03.mp4.
```
before:: (Kp = 0.2, Kd = 3.0, Ki = 0.004)
after :: (Kp = 0.2, Kd = 2.0, Ki = 0.002)
```

#### 2.2 Twiddle
After trying different ways to implement twiddle, I decided to update the hyperparameters by 50 steps, not considering the road curve. Also, the current error was compaired with the previous error instead of best error. This was because the parameters were not updated all the time because of the accidental best error.

Another difference from the quiz was that the quiz allowed us to run 100 steps in a function "run", but the project had to return to the simulator. Therefore, I introduced a variable called upstate to keep track of whether p was increased or decreased. Also, instead of using for loop, I introduced a variable called ind to update Kp, Ki, Kd in turn.
The implementation of that part is as follows.

```
double err = pid.TotalError();
 if(upstate[ind] && err < prev_err){
   best_err = err;
   dp[ind] *= 1.0;
   ind = (ind+1)%3;
 }else if(upstate[ind] && err >= prev_err){
   p[ind] -= dp[ind];
   upstate[ind] = false;
 }else if(!upstate[ind] && err < prev_err){
   best_err = err;
   dp[ind] *= 1.0;
   ind = (ind+1)%3;
 }else if(!upstate[ind] && err >= prev_err){
   p[ind] += dp[ind];
   dp[ind] *= 0.9;
   upstate[ind] = true;
   ind = (ind+1)%3;
 }

 if(upstate[ind] == true){
   p[ind] += dp[ind];         
   pid.Init(p);
 }else{
   p[ind] -= dp[ind];         
   if(p[ind] < 0.0){
     p[ind] = 0.0;
   }
   pid.Init(p);
 }
 prev_err = err;
```
Even though the tuning did not converge as quiz, the vehicle could drive safely without getting off the lane longer. The tuned hyperparameters were (Kp = 0.1534, Kd = 2.6, Ki = 0.0008) and the video of the driving was saved as  ./writeup/suc04.mp4.

#### 2.3 Switch modes
I switched between with or without twiddle depending on whether dp is set to 0 or not. The submitted code was when twidle was off as shown below, but if you comment out the 45th line and remove // ​​on the 44th line, it will be in twiddle mode.

```
43  std::vector<double> p = {0.1534, 0.0008, 2.6};
44  //std::vector<double> dp = {0.02, 0.001, 0.3};
45  std::vector<double> dp = {0.0, 0.0, 0.0};
```

### summary
Even though the vehicle could drive around the lake race track without getting off the lane, the drive was very shaky and did not seem confortable. The steering control using deep learning in project04 was smoother. I didn't know if smooth driving could be achieved if the hyperparameters were set more appropriately. Also, I would like to know the proper implementation of twiddle in this situation.
